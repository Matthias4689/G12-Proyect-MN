# -*- coding: utf-8 -*-
"""Proyecto MN

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vHdM4X7Or-cSzvATz_rB3IwNavJIcX4_
"""

# Librerías
import numpy as np
import matplotlib.pyplot as plt
import math

# Función que muestra la trayectoria del proyectil
def dibujo(coordX, coordY):
  plt.figure(figsize=(10,5))
  plt.plot(coordX, coordY, label="Trayectoria de la jabalina")
  plt.title("Simulación de la Trayectoria de la jabalina")
  plt.xlabel("Distancia horizontal (m)")
  plt.ylabel("Altura (m)")
  plt.legend()
  plt.grid(True)
  plt.show()

def simulacion(theta):
  # Parámetros modificables
  V = 43.25        # Velocidad inicial en m/s

  # Parametros jabalina
  m = 0.8         # Masa de la jabalina en kg
  A = 0.007       # Área transversal en m²

  # Parametros fisicos
  Cd = 0.04       # Coeficiente de arrastre
  rho = 1.225     # Densidad del aire en kg/m³
  g = 9.81        # Aceleración debida a la gravedad en m/s²

  # Tamaño del paso de tiempo en segundos
  h = 0.01

  # Condiciones iniciales
  # Coordenadas iniciales en metros
  x = 0.0 # En X
  y = 0.0 # En X

  # Tiempo inicial en segundos
  t = 0.0

  # Componentes de velocidad
  Vx = V * np.cos(theta)  # En X
  Vy = V * np.sin(theta)  # En Y

  # Listas para almacenar los resultados
  x_vals = [x]
  y_vals = [y]

  # Método de Runge-Kutta de cuarto orden
  while y >= 0:
    # Calcular k1 (Orden 1)
    k1x = h * (Vx - (0.5 * Cd * A * rho * Vx * np.abs(Vx)) / m)
    k1y = h * (Vy - g - (0.5 * Cd * A * rho * Vy * np.abs(Vy)) / m)

    # Calcular k2 (Orden 2)
    k2x = h * (Vx + 0.5 * k1x - g - (0.5 * Cd * A * rho * (Vx + 0.5 * k1x) * np.abs(Vx + 0.5 * k1x)) / m)
    k2y = h * (Vy + 0.5 * k1y - g - (0.5 * Cd * A * rho * (Vy + 0.5 * k1y) * np.abs(Vy + 0.5 * k1y)) / m)

    # Calcular k3 (Orden 3)
    k3x = h * (Vx + 0.5 * k2x - (0.5 * Cd * A * rho * (Vx + 0.5 * k2x) * np.abs(Vx + 0.5 * k2x)) / m)
    k3y = h * (Vy + 0.5 * k2y - g - (0.5 * Cd * A * rho * (Vy + 0.5 * k2y) * np.abs(Vy + 0.5 * k2y)) / m)

    # Calcular k4 (Orden 4)
    k4x = h * (Vx + k3x - (0.5 * Cd * A * rho * (Vx + k3x) * np.abs(Vx + k3x)) / m)
    k4y = h * (Vy + k3y - g - (0.5 * Cd * A * rho * (Vy + k3y) * np.abs(Vy + k3y)) / m)

    # Actualización de variables
    x = x + (k1x + 2 * k2x + 2 * k3x + k4x) / 6
    y = y + (k1y + 2 * k2y + 2 * k3y + k4y) / 6

    t = t + h

    Vx = Vx - (0.5 * Cd * A * rho * Vx * np.abs(Vx) * h) / m
    Vy = Vy - g * h - (0.5 * Cd * A * rho * Vy * np.abs(Vy) * h) / m

    # Almacenar los resultados
    x_vals.append(x)
    y_vals.append(y)

  return x_vals

x = 0

for grados in range(0, 91):

    radianes = grados * (math.pi / 180)

    xR = simulacion(radianes)

    xAux = max(xR)

    if(xAux >= x):

      x = xAux
      angulo = radianes * (180 / math.pi)

print(x," ",angulo)

# Parámetros modificables
theta = 0.785398  # Ángulo de elevación en radianes
V = 40.91     # Velocidad inicial en m/s
# Parametros jabalina
m = 0.8         # Masa de la jabalina en kg
A = 0.007       # Área transversal en m²

# Parametros fisicos
Cd = 0.04       # Coeficiente de arrastre
rho = 1.225     # Densidad del aire en kg/m³
g = 9.81        # Aceleración debida a la gravedad en m/s²

# Tamaño del paso de tiempo en segundos
h = 0.01

# Condiciones iniciales
# Coordenadas iniciales en metros
x = 0.0 # En X
y = 0.0 # En X

# Tiempo inicial en segundos
t = 0.0

# Componentes de velocidad
Vx = V * np.cos(theta)  # En X
Vy = V * np.sin(theta)  # En Y

# Listas para almacenar los resultados
x_vals = [x]
y_vals = [y]

# Método de Runge-Kutta de cuarto orden
while y >= 0:
    # Calcular k1 (Orden 1)
    k1x = h * (Vx - (0.5 * Cd * A * rho * Vx * np.abs(Vx)) / m)
    k1y = h * (Vy - g - (0.5 * Cd * A * rho * Vy * np.abs(Vy)) / m)

    # Calcular k2 (Orden 2)
    k2x = h * (Vx + 0.5 * k1x - g - (0.5 * Cd * A * rho * (Vx + 0.5 * k1x) * np.abs(Vx + 0.5 * k1x)) / m)
    k2y = h * (Vy + 0.5 * k1y - g - (0.5 * Cd * A * rho * (Vy + 0.5 * k1y) * np.abs(Vy + 0.5 * k1y)) / m)

    # Calcular k3 (Orden 3)
    k3x = h * (Vx + 0.5 * k2x - (0.5 * Cd * A * rho * (Vx + 0.5 * k2x) * np.abs(Vx + 0.5 * k2x)) / m)
    k3y = h * (Vy + 0.5 * k2y - g - (0.5 * Cd * A * rho * (Vy + 0.5 * k2y) * np.abs(Vy + 0.5 * k2y)) / m)

    # Calcular k4 (Orden 4)
    k4x = h * (Vx + k3x - (0.5 * Cd * A * rho * (Vx + k3x) * np.abs(Vx + k3x)) / m)
    k4y = h * (Vy + k3y - g - (0.5 * Cd * A * rho * (Vy + k3y) * np.abs(Vy + k3y)) / m)

    # Actualización de variables
    x = x + (k1x + 2 * k2x + 2 * k3x + k4x) / 6
    y = y + (k1y + 2 * k2y + 2 * k3y + k4y) / 6

    t = t + h

    Vx = Vx - (0.5 * Cd * A * rho * Vx * np.abs(Vx) * h) / m
    Vy = Vy - g * h - (0.5 * Cd * A * rho * Vy * np.abs(Vy) * h) / m

    # Almacenar los resultados
    x_vals.append(x)
    y_vals.append(y)

# Imprimir resultados
for i in range(len(x_vals)):
    print(f"Tiempo: {i*h:.2f} s - Posición (x, y): ({x_vals[i]:.2f} m, {y_vals[i]:.2f} m)")

# Imprime la gráfica con la trayectoria
dibujo(x_vals ,y_vals)